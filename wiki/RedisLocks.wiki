#labels Redis,Distributed,Concurrent,HighPerformance,Lock
This page shows how to use the [C# Redis Client] to take advantage of Redis's fast atomic server operations to enable high-performance *distributed locks* that can span across multiple app servers.

= Creating High Performance, Distributed Locking using Redis =

When you have a high-performance, scalable network data structure server like Redis accessible to your back end systems, a whole range of technical possibilities open up that we're previously difficult to achieve. Something as trivial as multi-server wide application-level locks was previously only achievable using dedicated, centralized server infrastructure and the crafting of some carefully custom concurrent programming logic. 

With Redis you get simplified access to intelligent atomic server operations that complete within a fraction of a millisecond. So the same normally CPU-intensive load generated by distributed lock when using a filesystem or RDBMS is barely noticeable on a Redis server.

[ServiceStackRedis Service Stack's C# Redis client] takes advantage of the convenience and safety offered by .NET's IDisposable interface and Redis's [http://code.google.com/p/redis/wiki/SetnxCommand SetNX operation] to provide a convenient API to implement your own custom *distributed locks*, ensuring at all times that only 1 client can execute the logic inside the lock. In the meantime when one of the Redis clients obtains the lock, the other clients enter into an 'exponential retry back-off multiplier state' continually retrying to obtain the lock at random intervals until they are finally successful.

== Simple API Usage ==
The locking functionality is available on the IRedisClient and IRedisTypedClient interfaces, the relevant portion of which is displayed below.
{{{
public interface IRedisClient
{
    ...
    IDisposable AcquireLock(string key);
    IDisposable AcquireLock(string key, TimeSpan timeOut);
}
}}}

Below are a couple examples showing how to use the API in some typical usage scenarios.

== Example: Multiple clients acquiring the same lock ==

The example below shows the behaviour of running 5 concurrent clients trying to acquire the same lock at the same time.
An artificial delay is added inside the lock to simulate a cpu-intensive workload.

{{{
//The number of concurrent clients to run
const int noOfClients = 5;
var asyncResults = new List<IAsyncResult>(noOfClients);
for (var i = 1; i <= noOfClients; i++)
{
	var clientNo = i;
	var actionFn = (Action)delegate
	{
		var redisClient = new RedisClient(TestConfig.SingleHost);
		using (redisClient.AcquireLock("testlock"))
		{
			Console.WriteLine("client {0} acquired lock", clientNo);
			var counter = redisClient.Get<int>("atomic-counter");

			//Add an artificial delay to demonstrate locking behaviour
			Thread.Sleep(100);

			redisClient.Set("atomic-counter", counter + 1);
			Console.WriteLine("client {0} released lock", clientNo);
		}
	};

	//Asynchronously invoke the above delegate
	asyncResults.Add(actionFn.BeginInvoke(null, null));
}

//Wait at most 1 second for all the threads to complete
asyncResults.WaitAll(TimeSpan.FromSeconds(1));

//Print out the 'atomic-counter' result
using (var redisClient = new RedisClient(TestConfig.SingleHost))
{
	var counter = redisClient.Get<int>("atomic-counter");
	Console.WriteLine("atomic-counter after 1sec: {0}", counter);
}

/*Output:
client 1 acquired lock
client 1 released lock
client 3 acquired lock
client 3 released lock
client 4 acquired lock
client 4 released lock
client 5 acquired lock
client 5 released lock
client 2 acquired lock
client 2 released lock
atomic-counter after 1sec: 5
*/
}}}

The above

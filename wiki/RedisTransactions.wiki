This page provides examples on how to create atomic Redis transactions with [ServiceStackRedis Service Stack's C# Redis Client]

= Introduction =

One of the main features of Redis is the ability to construct custom atomic operations. This is achieved by utilizing Redis's [http://code.google.com/p/redis/wiki/MultiExecCommand MULTI/EXEC/DISCARD] operations.

[ServiceStackRedis Service Stack's C# Redis Client] makes it easy to utilize Redis transactions by providing a [IRedisTransaction strongly-typed IRedisTransaction API] with convenience methods to allow you to combine any [IRedisClient] operation within a single transaction.

Creating a transaction is done by calling `IRedisClient.CreateTransaction()`. 
From there you 'Queue' up all operations you want to be apart of the transaction by using one of the convenient `IRedisTransaction.QueueCommand()` overloads. After that you can choose to execute all the operations by issuing the `IRedisTransaction.Commit()` method which will send the 'EXEC' command to execute all the Queued commands and process their callbacks.

If you don't call the `Commit()` method before the end of the using block, the `Dispose()` method will automatically invoke the `Rollback()` method which will send the 'DISCARD' command disposing of the current transaction and resetting the Redis client connection back to normal.

== Redis Transaction Examples ==

Below is a simple example showing how to queue up Redis operations with and without a callback.

{{{

int callbackResult;
using (var trans = redis.CreateTransaction())
{
  trans.QueueCommand(r => r.Increment("key"));  
  trans.QueueCommand(r => r.Increment("key"), i => callbackResult = i);  

  trans.Commit();
}
//The value of "key" is incremented twice

}}}

=== Other common examples ===
The full-source code and other common examples can be found on the [http://code.google.com/p/servicestack/source/browse/trunk/Common/ServiceStack.Redis/ServiceStack.Redis.Tests/RedisTransactionCommonTests.cs common transaction tests page].

{{{
private const string Key = "multitest";

[Test]
public void Can_Set_and_Expire_key_in_atomic_transaction()
{
	var oneSec = TimeSpan.FromSeconds(1);

	Assert.That(Redis.GetString(Key), Is.Null);
	using (var trans = Redis.CreateTransaction())			//Calls 'MULTI'
	{
		trans.QueueCommand(r => r.SetString(Key, "a"));		//Queues 'SET a'
		trans.QueueCommand(r => r.ExpireKeyIn(Key, oneSec));	//Queues 'EXPIRESIN a 1'

		trans.Commit();						//Calls 'EXEC'

	}								//Calls 'DISCARD' if 'EXEC' wasn't called

	Assert.That(Redis.GetString(Key), Is.EqualTo("a"));
	Thread.Sleep(TimeSpan.FromSeconds(2));
	Assert.That(Redis.GetString(Key), Is.Null);
}

[Test]
public void Can_Pop_priority_message_from_SortedSet_and_Add_to_workq_in_atomic_transaction()
{
	var messages = new List<string> { "message4", "message3", "message2" };

	Redis.AddToList("workq", "message1");

	var priority = 1;
	messages.ForEach(x => Redis.AddToSortedSet("prioritymsgs", x, priority++));

	var highestPriorityMessage = Redis.PopFromSortedSetItemWithHighestScore("prioritymsgs");

	using (var trans = Redis.CreateTransaction())
	{
		trans.QueueCommand(r => r.RemoveFromSortedSet("prioritymsgs", highestPriorityMessage));
		trans.QueueCommand(r => r.AddToList("workq", highestPriorityMessage));	

		trans.Commit();											
	}

	Assert.That(Redis.GetAllFromList("workq"), 
		Is.EquivalentTo(new List<string> { "message1", "message2" }));
	Assert.That(Redis.GetAllFromSortedSet("prioritymsgs"), 
		Is.EquivalentTo(new List<string> { "message3", "message4" }));
}

}}}